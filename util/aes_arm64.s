// Copyright 2017 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build arm64,!gccgo

#include "textflag.h"
DATA rotInvSRows<>+0x00(SB)/8, $0x080f0205040b0e01
DATA rotInvSRows<>+0x08(SB)/8, $0x00070a0d0c030609
GLOBL rotInvSRows<>(SB), (NOPTR+RODATA), $16
DATA invSRows<>+0x00(SB)/8, $0x0b0e0104070a0d00
DATA invSRows<>+0x08(SB)/8, $0x0306090c0f020508
GLOBL invSRows<>(SB), (NOPTR+RODATA), $16
// func ·encryptAes128(xk *uint32, dst, src *byte)
TEXT ·encryptAes128(SB),NOSPLIT,$0
	MOVD	xk+0(FP), R10
	MOVD	dst+8(FP), R11
	MOVD	src+16(FP), R12

	VLD1	(R12), [V0.B16]

	VLD1.P	64(R10), [V5.B16, V6.B16, V7.B16, V8.B16]
	VLD1.P	64(R10), [V9.B16, V10.B16, V11.B16, V12.B16]
	VLD1.P	48(R10), [V13.B16, V14.B16, V15.B16]
	AESE	V5.B16, V0.B16
	AESMC	V0.B16, V0.B16
	AESE	V6.B16, V0.B16
	AESMC	V0.B16, V0.B16
	AESE	V7.B16, V0.B16
	AESMC	V0.B16, V0.B16
	AESE	V8.B16, V0.B16
	AESMC	V0.B16, V0.B16
	AESE	V9.B16, V0.B16
	AESMC	V0.B16, V0.B16
	AESE	V10.B16, V0.B16
	AESMC	V0.B16, V0.B16
	AESE	V11.B16, V0.B16
	AESMC	V0.B16, V0.B16
	AESE	V12.B16, V0.B16
	AESMC	V0.B16, V0.B16
	AESE	V13.B16, V0.B16
	AESMC	V0.B16, V0.B16
	AESE	V14.B16, V0.B16
	VEOR    V0.B16, V15.B16, V0.B16
	VST1	[V0.B16], (R11)
	RET

    // func aes128MMO(xk *uint32, dst, src *byte)
TEXT ·aes128MMO(SB),NOSPLIT,$0
	MOVD	xk+0(FP), R10
	MOVD	dst+8(FP), R11
	MOVD	src+16(FP), R12

	VLD1	(R12), [V0.B16]

	VLD1.P	64(R10), [V5.B16, V6.B16, V7.B16, V8.B16]
	VLD1.P	64(R10), [V9.B16, V10.B16, V11.B16, V12.B16]
	VLD1.P	48(R10), [V13.B16, V14.B16, V15.B16]
	AESE	V5.B16, V0.B16
	AESMC	V0.B16, V0.B16
	AESE	V6.B16, V0.B16
	AESMC	V0.B16, V0.B16
	AESE	V7.B16, V0.B16
	AESMC	V0.B16, V0.B16
	AESE	V8.B16, V0.B16
	AESMC	V0.B16, V0.B16
	AESE	V9.B16, V0.B16
	AESMC	V0.B16, V0.B16
	AESE	V10.B16, V0.B16
	AESMC	V0.B16, V0.B16
	AESE	V11.B16, V0.B16
	AESMC	V0.B16, V0.B16
	AESE	V12.B16, V0.B16
	AESMC	V0.B16, V0.B16
	AESE	V13.B16, V0.B16
	AESMC	V0.B16, V0.B16
	AESE	V14.B16, V0.B16
	VEOR    V0.B16, V15.B16, V0.B16
    VLD1	(R12), [V5.B16]
    VEOR    V0.B16, V5.B16, V0.B16
	VST1	[V0.B16], (R11)
	RET


// func expandKeyAsm(key *byte, enc *uint32) {
// Note that round keys are stored in uint128 format, not uint32
TEXT ·expandKeyAsm(SB),NOSPLIT,$0
	MOVD	key+0(FP), R9
	MOVD	enc+8(FP), R10
    MOVD    $10,R8
	LDP	rotInvSRows<>(SB), (R0, R1)
	VMOV	R0, V3.D[0]
	VMOV	R1, V3.D[1]
	VEOR	V0.B16, V0.B16, V0.B16 // All zeroes
	MOVW	$1, R13
	LDPW	(R9), (R4, R5)
	LDPW	8(R9), (R6, R7)
	STPW.P	(R4, R5), 8(R10)
	STPW.P	(R6, R7), 8(R10)
	MOVW	$0x1b, R14
ks128Loop:
		VMOV	R7, V2.S[0]
		WORD	$0x4E030042       // TBL V3.B16, [V2.B16], V2.B16
		AESE	V0.B16, V2.B16    // Use AES to compute the SBOX
		EORW	R13, R4
		LSLW	$1, R13           // Compute next Rcon
		ANDSW	$0x100, R13, ZR
		CSELW	NE, R14, R13, R13 // Fake modulo
		SUBS	$1, R8
		VMOV	V2.S[0], R0
		EORW	R0, R4
		EORW	R4, R5
		EORW	R5, R6
		EORW	R6, R7
		STPW.P	(R4, R5), 8(R10)
		STPW.P	(R6, R7), 8(R10)
	BNE	ks128Loop
ksDone:
	RET

// func xor16(dst, a, b *byte)
TEXT ·xor16(SB), NOSPLIT|NOFRAME, $0
	MOVD	dst+0(FP), R0
	MOVD	a+8(FP), R1
	MOVD	b+16(FP), R2
	LDP.P	16(R1), (R11, R12)
	LDP.P	16(R2), (R13, R14)
	EOR	R11, R13, R13
	EOR	R12, R14, R14
	STP.P	(R13, R14), 16(R0)
	RET
